--Listing the TOP n Values

USE northwind
SELECT TOP 5       orderid, productid, quantity
FROM [order details]
ORDER BY quantity DESC   --Specifies the Range of Values in the ORDER BY Clause
						 --order the result set then retrieve the top n from it
GO
/*
		result : 10764,11072,10398,10451,10515
*/
				/***************/
--Returns Ties if WITH TIES Is Used

USE northwind
SELECT TOP 5 WITH TIES    /*
						  return the rows with the same quantity
						  of the retrieved rows from top n 
						  no matter the number of the rows retrieved are
							**WITH TIES** 
							Specifies that additional rows
							be returned from the base result set 
							with the same value in the ORDER BY columns 
							appearing as the last of the TOP n (PERCENT) rows.
							TOP ...WITH TIES can be specified only in SELECT statements,
							and only if an ORDER BY clause is specified.
						  */
		orderid, productid, quantity
FROM [order details]
ORDER BY quantity DESC      --have to be used with (top n with ties)
GO
			------------------------

USE northwind
SELECT productid, orderid, quantity
FROM [Order Details]
GO
				/***************/

USE northwind
SELECT productid, SUM(quantity) AS total_quantity
FROM [Order Details]
GROUP BY productid
GO
				/***************/
USE northwind
SELECT productid, SUM(quantity) AS total_quantity
FROM [Order Details]
WHERE productid = 2     --Only rows that satisfy 
						--the WHERE clause are grouped

GROUP BY productid
GO
				/***************/

USE northwind
SELECT productid, SUM(quantity) AS total_quantity
FROM [Order Details]
GROUP BY productid
HAVING SUM(quantity)>=30   --Using the GROUP BY Clause
						   --with the HAVING Clause(filtering)
GO
				/***************/
/*
The ROLLUP operator is useful in generating reports
that contain subtotals and totals. 
ROLLUP operator generates a result set that is similar
to the result sets generated by the CUBE operator.

1- CUBE generates a result set that shows aggregates for all combinations
 of values in the selected columns.
**Generates ROLLUP super-aggregate rows and cross tab rows
**Outputs a grouping for all combinations of expressions
**Column order doesn’t affect CUBE output

2- ROLLUP generates a result set that shows aggregates for
 a hierarchy of values in the selected columns.

**Generates subtotal or super-aggregate rows and grand total row
**One row with a subtotal is generated for each unique combination of 
the columns in the select list
**Column order affects output groupings (rollup direction)
*/
--Example using Rollup
USE northwind
SELECT productid, orderid, SUM(quantity) AS total_quantity
FROM [Order Details]
GROUP BY productid, orderid
WITH ROLLUP
ORDER BY productid, orderid
GO

use AdventureWorks

SELECT ProductID,Shelf,SUM(Quantity) AS QtySum
FROM Production.ProductInventory
WHERE ProductID<6
GROUP BY ROLLUP(ProductID,Shelf)
/*
ROLLUP(),CUBE() not compatible in mode 90 only in 100 & more
use WITH ROLLUP,WITH CUBE instead
*/
					/***************/
--Example using Cube
USE northwind
SELECT productid, orderid, SUM(quantity) AS total_quantity
FROM [Order Details]
GROUP BY productid, orderid
WITH CUBE 
ORDER BY productid, orderid
GO

use AdventureWorks

SELECT ProductID,Shelf,SUM(Quantity) AS QtySum
FROM Production.ProductInventory
WHERE ProductID<6
GROUP BY CUBE(ProductID, Shelf)

					/***************/
--Example using Grouping with CUBE
--		GROUPING (productid) = 1 
--		represents summary values in the preceding column(productid = ALL or NULL)

--		GROUPING (productid) = 0 
--		represents detail values in the preceding column

SELECT productid, GROUPING (productid)
      ,orderid, GROUPING (orderid)
      ,SUM(quantity) AS total_quantity
FROM [Order Details]
GROUP BY productid, orderid
WITH CUBE 
ORDER BY productid, orderid
GO

					/***************/
/* Table contents

Item                 Color                Quantity                   
-------------------- -------------------- -------------------------- 
Table                Blue                 124                        
Table                Red                  223                        
Chair                Blue                 101                        
Chair                Red                  210 
*/
/*
			use Adventureworks
			SELECT CASE WHEN (GROUPING(Item) = 1) THEN 'ALL'
						ELSE ISNULL(Item, 'UNKNOWN')
				   END AS Item,
				   CASE WHEN (GROUPING(Color) = 1) THEN 'ALL'
						ELSE ISNULL(Color, 'UNKNOWN')
				   END AS Color,
				   SUM(Quantity) AS QtySum
			FROM Inventory
			GROUP BY Item, Color WITH ROLLUP
			go
*/
/*	Result of using Rollup
	Item                 Color                QtySum                     
	-------------------- -------------------- -------------------------- 
	Chair                Blue                 101.00                     
	Chair                Red                  210.00                     
=>	Chair                ALL                  311.00                     
	Table                Blue                 124.00                     
	Table                Red                  223.00                     
=>	Table                ALL                  347.00                     
	ALL                  ALL                  658.00   
*/
/*	Result of using Cube 

	Item                 Color                QtySum                     
	-------------------- -------------------- -------------------------- 
	Chair                Blue                 101.00                     
	Chair                Red                  210.00                     
=>	Chair                ALL                  311.00                     
	Table                Blue                 124.00                     
	Table                Red                  223.00                     
=>	Table                ALL                  347.00                     
	ALL                  ALL                  658.00 

these two additional rows are returned at the end  
	
=>	ALL                  Blue                 225.00                     
=>	ALL                  Red                  433.00 
                    
*/
				--------------------------
/*
ROLLUP generates a result set showing the aggregates for 
a hierarchy of values in selected columns
*/
				--------------------------
--Using the COMPUTE clause
USE northwind
SELECT productid, orderid, quantity 
FROM [Order Details]
--ORDER BY productid, orderid
COMPUTE SUM(quantity)
GO
--Equivalent to 
select sum(quantity)
from [Order Details]
					  /***************/
USE northwind
SELECT productid, orderid, quantity 
FROM [Order Details]
ORDER BY productid, orderid
COMPUTE SUM(quantity) BY productid  --All expressions in the compute by 
									--list must also be present in the 
									--order by list with the same order.
COMPUTE SUM(quantity)
GO
--Both COMPUTE and COMPUTE BY can be used in the same query

use AdventureWorks

SELECT SalesOrderID, UnitPrice, UnitPriceDiscount
FROM Sales.SalesOrderDetail 
ORDER BY SalesOrderID 
COMPUTE SUM(UnitPrice), SUM(UnitPriceDiscount) By SalesOrderID

SELECT SalesPersonID, CustomerID, OrderDate, SubTotal, TotalDue 
FROM Sales.SalesOrderHeader 
ORDER BY SalesPersonID, OrderDate 
COMPUTE SUM(SubTotal), SUM(TotalDue) BY SalesPersonID

/*
One clear advantage for using COMPUTE & COMPUTE BYis that summary 
of information at different levels can be returned in a single call instead of 
multiple calls.
*/
					  /***************/
/*
GROUP BY
1. Provides summarized data sets for aggregation functions
2. When using aggregation functions, columns in SELECT list must either be 
in a function or in the GROUP BY
3. Note that in the given GROUP BY example the column grouped on is in a joined table

HAVING
1. Can be used in lieu of WHERE
2. Filters grouping data after the grouping has occurred but before sent as results
*/

use AdventureWorks;

SELECT SalesOrderID, SUM(LineTotal) AS SubTotal
FROM Sales.SalesOrderDetail
GROUP BY SalesOrderID
ORDER BY SalesOrderID
 
SELECT SalesOrderID, SUM(LineTotal) AS SubTotal
FROM Sales.SalesOrderDetail
GROUP BY SalesOrderID
HAVING SUM(LineTotal) > 100000.00
ORDER BY SalesOrderID


select count(ContactID)  
from Person .Contact 
having count(ContactID) >500
--select ContactID  from Person .Contact having count(ContactID) >500 --error
/*can use having instead of where "col's in the select statment have to be 
contained in either an aggregate fn. or a group by clause"
*/


SELECT A.City, COUNT(E. EmployeeID) EmployeeCount
FROM HumanResources.Employee E 
INNER JOIN Person.Address A 
ON E.EmployeeID = A.AddressID 
GROUP BY A.City 
ORDER BY A.City;

SELECT DATEPART(yyyy,OrderDate) AS 'Year' 
,SUM(TotalDue) AS 'Total Order Amount' 
FROM Sales.SalesOrderHeader 
GROUP BY DATEPART(yyyy,OrderDate) 
HAVING DATEPART(yyyy,OrderDate) >= '2003' 
ORDER BY DATEPART(yyyy,OrderDate)
								---------------------------------------
									/*****Grouping Set****/
/*									
--	New GROUP BY operator that aggregates several groupings in one query
--	Eliminates multiple GROUP BY queries  
"eases the amount of time and work required by the developer"
--	Supports additional options as ability to use with ROLLUP and CUBE 
operators "Since GROUPING SETS provide a new angle on grouping data"
certain types of dimensional queries are optimized with GROUPING SETS.  
For example, ROLLUP with 100 columns results in a UNION of 100 +1 results 
and CUBE results in 100 squared -1 results while grouping sets can produce an 
intermediate number of results.  
Sometimes not all the dimensions produced by CUBE would be needed.
*/
use AdventureWorks

SELECT T.[Group] AS 'Region'
	, T.CountryRegionCode AS 'Country'
    ,S.Name AS 'Store', H.SalesPersonID
    ,SUM(TotalDue) AS 'Total Sales'
    
FROM Sales.Customer C
    INNER JOIN Sales.Store S
        ON C.CustomerID  = S.CustomerID 
    INNER JOIN Sales.SalesTerritory T
        ON C.TerritoryID  = T.TerritoryID 
    INNER JOIN Sales.SalesOrderHeader H
        ON C.CustomerID = H.CustomerID

WHERE T.[Group] = 'Europe'
    AND T.CountryRegionCode IN('DE', 'FR')
    AND SUBSTRING(S.Name,1,4)IN('Vers', 'Spa ')
    
GROUP BY GROUPING SETS
    (T.[Group], T.CountryRegionCode, S.Name, H.SalesPersonID)
    
ORDER BY T.[Group], T.CountryRegionCode, S.Name, H.SalesPersonID;
								-----------------------------------------------
/*
GROUP BY ALL will be removed in a future version of Microsoft SQL Server. 
Avoid using GROUP BY ALL in new development work, and plan to modify 
applications that currently use it
GROUP BY ALL should not be used with queries that access remote tables. 
It is not supported in such queries if there is also a WHERE clause in the query, 
and without a WHERE clause it adds no value.
If you use ALL, the query results include all groups produced by the GROUP BY 
clause, even if some of the groups have no rows that meet the search conditions. 
Without ALL, a SELECT statement that includes GROUP BY does not show 
groups for which no rows qualify.
*/
USE AdventureWorks;
GO
SELECT ProductID, AVG(UnitPrice) AS 'Average Price'
FROM Sales.SalesOrderDetail
WHERE OrderQty > 10
GROUP BY ALL ProductID
ORDER BY ProductID ;
GO
/*
ProductID        Average Price
--------------------------------------
707						20.7765
708						20.7482
709						6.175
710						NULL
711						20.7285
712						5.7592
*/								
								-----------------------------------------------
										/*****Pivot*****/
USE AdventureWorks
GO
    -- Creating Test Table
CREATE TABLE Product
(
	Cust VARCHAR(25), 
	Product VARCHAR(20), 
	QTY INT
)
GO
    -- Inserting Data into Table
INSERT INTO Product(Cust, Product, QTY)
        VALUES('KATE','VEG',2)
INSERT INTO Product(Cust, Product, QTY)
        VALUES('KATE','SODA',6)
INSERT INTO Product(Cust, Product, QTY)
        VALUES('KATE','MILK',1)
INSERT INTO Product(Cust, Product, QTY)
        VALUES('KATE','BEER',12)
INSERT INTO Product(Cust, Product, QTY)
        VALUES('FRED','MILK',3)
INSERT INTO Product(Cust, Product, QTY)
        VALUES('FRED','BEER',24)
INSERT INTO Product(Cust, Product, QTY)
        VALUES('KATE','VEG',3)
GO
    -- Selecting and checking entires in table
SELECT *
    FROM Product
GO


    -- Pivot Table ordered by PRODUCT
SELECT Product, FRED, KATE  --col.'s aliases
    FROM (
    SELECT  Cust ,Product, QTY
        FROM dbo.Product) up
            PIVOT (SUM(QTY) FOR Cust IN (FRED, KATE)) AS pvt
    ORDER BY Product
GO


    -- Pivot Table ordered by CUST
SELECT Cust, VEG, SODA, MILK, BEER, CHIPS
    FROM (
    SELECT Cust, Product, QTY
        FROM Product) up
            PIVOT (SUM(QTY) FOR Product IN (VEG, SODA, MILK, BEER, CHIPS)) AS pvt
    ORDER BY Cust
GO


    -- Unpivot Table ordered by CUST
SELECT Cust, PRODUCT, QTY
    FROM
    (
    SELECT Cust, VEG, SODA, MILK, BEER, CHIPS
        FROM (
        SELECT Cust, Product, QTY
            FROM Product) up
                PIVOT
        ( SUM(QTY) FOR Product IN (VEG, SODA, MILK, BEER, CHIPS)) AS pvt) p
            UNPIVOT
    (QTY FOR PRODUCT IN (VEG, SODA, MILK, BEER, CHIPS)
    ) AS Unpvt
GO

    -- Clean up database
DROP TABLE Product
GO
										
 


